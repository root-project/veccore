<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VecCore: VecCore</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VecCore<span id="projectnumber">&#160;0.8.1</span>
   </div>
   <div id="projectbrief">C++ Library for Portable SIMD Vectorization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">VecCore </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <b>VecCore</b> is a simple abstraction layer on top of other vectorization libraries. It provides an architecture-independent <a class="el" href="md_doc_api.html">API</a> for expressing vector operations on data. Code written with this API can then be dispatched to one of several <a class="el" href="md_doc_backends.html">backends</a> implemented using libraries like <a href="https://github.com/VcDevel/Vc">Vc</a>, <a href="https://github.com/edanor/umesimd">UME::SIMD</a>, or a scalar implementation. This allows one to get the best performance on platforms supported by Vc and UME::SIMD without losing portability to unsupported architectures like PowerPC, for example, where the scalar backends can be used instead without requiring changes in user code. Another advantage is that, unlike with compiler intrinsics, the same code can be compiled for SSE, AVX2, AVX512, etc, without modifications. With the addition of new backends, such as the new backend based on C++20 and <code>std::experimental::simd</code>, users can automatically take advantage of new features and better performance. This backend supports AVX512 on Intel/AMD64 and NEON on ARM/ARM64, with best performance in most cases. However, it does require compiling code in C++20 mode, which may not always be possible, so there is still an advantage in using it via VecCore's implementation to have a fallback when C++20 is not avaialble.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Example</h1>
<p>The <a href="bench/">bench</a> directory of the repository has several usage examples of the VecCore API that are used to compare how different backends perform in various circumstances. Below we show how to convert a scalar function to compute a <a href="https://en.wikipedia.org/wiki/Julia_set">Julia Set</a> to work with SIMD instructions:</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Scalar Implementation</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> julia(<span class="keywordtype">float</span> xmin, <span class="keywordtype">float</span> xmax, <span class="keywordtype">int</span> nx, flaot ymin, <span class="keywordtype">float</span> ymax, <span class="keywordtype">int</span> ny,</div>
<div class="line">           <span class="keywordtype">int</span> max_iter, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *image, <span class="keywordtype">float</span> real, <span class="keywordtype">float</span> im)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> dx = (xmax - xmin) / nx;</div>
<div class="line">    <span class="keywordtype">float</span> dy = (ymax - ymin) / ny;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nx; ++i) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ny; ++j) {</div>
<div class="line">            <span class="keywordtype">int</span> k = 0;</div>
<div class="line">            <span class="keywordtype">float</span> x = xmin + i * dx, cr = real, zr = x;</div>
<div class="line">            <span class="keywordtype">float</span> y = ymin + j * dy, ci = im, zi = y;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">do</span> {</div>
<div class="line">                x  = zr*zr - zi*zi + cr;</div>
<div class="line">                y  = 2.0f * zr*zi + ci;</div>
<div class="line">                zr = x;</div>
<div class="line">                zi = y;</div>
<div class="line">            } <span class="keywordflow">while</span> (++k &lt; max_iter &amp;&amp; (zr*zr + zi*zi &lt; 4.0f));</div>
<div class="line"> </div>
<div class="line">            image[ny*i + j] = k;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3"></a>
SIMD Implementation using VecCore</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> julia_v(Scalar&lt;T&gt; xmin, Scalar&lt;T&gt; xmax, <span class="keywordtype">size_t</span> nx, Scalar&lt;T&gt; ymin, Scalar&lt;T&gt; ymax, <span class="keywordtype">size_t</span> ny,</div>
<div class="line">             Scalar&lt;Index&lt;T&gt;&gt; max_iter, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *image, Scalar&lt;T&gt; real, Scalar&lt;T&gt; im)</div>
<div class="line">{</div>
<div class="line">    T iota(0.0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; VectorSize&lt;T&gt;(); ++i)</div>
<div class="line">        Set&lt;T&gt;(iota, i, i);</div>
<div class="line"> </div>
<div class="line">    T dx = T(xmax - xmin) / T(nx);</div>
<div class="line">    T dy = T(ymax - ymin) / T(ny), dyv = iota * dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; j += VectorSize&lt;T&gt;()) {</div>
<div class="line">            Scalar&lt;Index&lt;T&gt;&gt; k(0);</div>
<div class="line">            T x = xmin + T(i) * dx,       cr = real, zr = x;</div>
<div class="line">            T y = ymin + T(j) * dy + dyv, ci = im, zi = y;</div>
<div class="line"> </div>
<div class="line">            Index&lt;T&gt; kv(0);</div>
<div class="line">            Mask&lt;T&gt; m(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">do</span> {</div>
<div class="line">                x = zr*zr - zi*zi + cr;</div>
<div class="line">                y = T(2.0) * zr*zi + ci;</div>
<div class="line">                MaskedAssign&lt;T&gt;(zr, m, x);</div>
<div class="line">                MaskedAssign&lt;T&gt;(zi, m, y);</div>
<div class="line">                MaskedAssign&lt;Index&lt;T&gt;&gt;(kv, m, ++k);</div>
<div class="line">                m = zr*zr + zi*zi &lt; T(4.0);</div>
<div class="line">            } <span class="keywordflow">while</span> (k &lt; max_iter &amp;&amp; !MaskEmpty(m));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; VectorSize&lt;T&gt;(); ++k)</div>
<div class="line">                image[ny*i + j + k] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) Get(kv, k);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The differences appear where branching is required and masks need to be used instead of simple conditionals. In some places, casting scalars to the correct type is also necessary in order enable their promotion to the correct SIMD vector type.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Performance</h3>
<p>Gains in performance usually depend not only on the code being vectorized, but also on the runtime characteristics of the actual computations. For example, when computing Julia sets, it matters what structure it has, as that determines how much coherence there is between nearby pixels. That is, the more iterations that get computed in vector mode for nearby pixels, the more performance is improved. On the other hand, when more iterations are performed with elements masked out, speedup is lower. Therefore, the fractal with the largest interior consisting of diverging points (shown in black) has the largest speedup. The figure below illustrates this fact for different fractals (left) by showing the speedup as the point where the lines cross the axis of the radial plot (right).</p>
<p><img src="julia.gif" alt="Julia Set Animation" width="400px" class="inline"/> &#160; &#160; <img src="julia-speedup.gif" alt="Julia Set Animation" width="320px" class="inline"/> </p>
<h1><a class="anchor" id="autotoc_md5"></a>
Supported Platforms</h1>
<p>VecCore supports Linux, Mac OS X, and Windows. To compile software using VecCore, you will need a compiler with support for C++11. We recommend using at least the following compiler versions:</p>
<ul>
<li>GCC 6.5.0</li>
<li>Clang 9.0</li>
<li>AppleClang 11.0</li>
<li>Intel® C/C++ Compiler 19.1</li>
<li>Microsoft Visual Studio 17 2019</li>
</ul>
<p>Additionally, you will need CMake 3.9 or later, and you may want to install a SIMD library such as</p>
<ul>
<li><a href="https://github.com/VcDevel/Vc">Vc</a> (version 1.4 or later)</li>
<li><a href="https://github.com/edanor/umesimd">UME::SIMD</a> (version 0.8.1 or later)</li>
<li><a href="https://gcc.gnu.org/gcc-11/changes.html#libstdcxx">std::experimental::simd</a> (included in libstdc++ from GCC 11 or later)</li>
</ul>
<p>and/or</p>
<ul>
<li><a href="http://developer.nvidia.com/cuda">Nvidia's CUDA SDK</a> (version 10.2 or later).</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Documentation</h1>
<p>The documentation can be generated by Doxygen by enabling <code>-DBUILD_DOCS=True</code> when configuring, then building the <code>doxygen</code> target with <code>make doxygen</code>. It is also available online at <a href="https://root-project.github.io/veccore">https://root-project.github.io/veccore</a>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Publications</h1>
<p>A list of publications is available <a class="el" href="md_doc_publications.html">here</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
