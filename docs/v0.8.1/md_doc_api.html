<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VecCore: VecCore API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VecCore<span id="projectnumber">&#160;0.8.1</span>
   </div>
   <div id="projectbrief">C++ Library for Portable SIMD Vectorization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">VecCore API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>VecCore defines <em>backend</em> structures in order to group similar <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> vector types together to allow their use in hardware independent implementations of vectorized algorithms. The backend types are also used to define a uniform interface for operations such as masking, loading and storing data, etc. Below we give an overview of the common interfaces VecCore offers to abstract over SIMD vector types from each backend.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Backend Types</h2>
<p>Historically, VecCore has offered the following alias to common scalar types:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacevecCore.html">vecCore</a> {</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#abcb486d2cd77bb90fba82d5af11758dd">Bool_s</a>   = bool;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a86870388269fc1e030dbb5862631d139">Float_s</a>  = float;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a318bd19a738ea1c1357a255e5ce59d0c">Double_s</a> = double;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a8bab6e87189c3911511530eff7257072">Int_s</a>    = int32_t;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a7399f98dc1974ce44f16743bf3076708">Int32_s</a>  = int32_t;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a46887a61085372e675f5d03c8667a1de">Int64_s</a>  = int64_t;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#afc1f49d20309f437867242a8822d4a91">UInt_s</a>   = uint32_t;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a0f5e57779c82010c22a27dcbdebe4fbd">UInt32_s</a> = uint32_t;</div>
<div class="line">  <span class="keyword">using </span><a class="code hl_typedef" href="namespacevecCore.html#a6b62d4ccb8f17820d8390e6d23958397">UInt64_s</a> = uint64_t;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacevecCore_html"><div class="ttname"><a href="namespacevecCore.html">vecCore</a></div><div class="ttdef"><b>Definition:</b> <a href="Deprecated_8h_source.html#l00012">Deprecated.h:12</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a0f5e57779c82010c22a27dcbdebe4fbd"><div class="ttname"><a href="namespacevecCore.html#a0f5e57779c82010c22a27dcbdebe4fbd">vecCore::UInt32_s</a></div><div class="ttdeci">uint32_t UInt32_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00020">Types.h:20</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a318bd19a738ea1c1357a255e5ce59d0c"><div class="ttname"><a href="namespacevecCore.html#a318bd19a738ea1c1357a255e5ce59d0c">vecCore::Double_s</a></div><div class="ttdeci">double Double_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00024">Types.h:24</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a46887a61085372e675f5d03c8667a1de"><div class="ttname"><a href="namespacevecCore.html#a46887a61085372e675f5d03c8667a1de">vecCore::Int64_s</a></div><div class="ttdeci">int64_t Int64_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00016">Types.h:16</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a6b62d4ccb8f17820d8390e6d23958397"><div class="ttname"><a href="namespacevecCore.html#a6b62d4ccb8f17820d8390e6d23958397">vecCore::UInt64_s</a></div><div class="ttdeci">uint64_t UInt64_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00021">Types.h:21</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a7399f98dc1974ce44f16743bf3076708"><div class="ttname"><a href="namespacevecCore.html#a7399f98dc1974ce44f16743bf3076708">vecCore::Int32_s</a></div><div class="ttdeci">int32_t Int32_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00015">Types.h:15</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a86870388269fc1e030dbb5862631d139"><div class="ttname"><a href="namespacevecCore.html#a86870388269fc1e030dbb5862631d139">vecCore::Float_s</a></div><div class="ttdeci">float Float_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00023">Types.h:23</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a8bab6e87189c3911511530eff7257072"><div class="ttname"><a href="namespacevecCore.html#a8bab6e87189c3911511530eff7257072">vecCore::Int_s</a></div><div class="ttdeci">int32_t Int_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00013">Types.h:13</a></div></div>
<div class="ttc" id="anamespacevecCore_html_abcb486d2cd77bb90fba82d5af11758dd"><div class="ttname"><a href="namespacevecCore.html#abcb486d2cd77bb90fba82d5af11758dd">vecCore::Bool_s</a></div><div class="ttdeci">bool Bool_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00009">Types.h:9</a></div></div>
<div class="ttc" id="anamespacevecCore_html_afc1f49d20309f437867242a8822d4a91"><div class="ttname"><a href="namespacevecCore.html#afc1f49d20309f437867242a8822d4a91">vecCore::UInt_s</a></div><div class="ttdeci">uint32_t UInt_s</div><div class="ttdef"><b>Definition:</b> <a href="Types_8h_source.html#l00018">Types.h:18</a></div></div>
</div><!-- fragment --><p>Since these types are part of standard C++, newer versions of VecCore use them directly in its implementation, and users are also encouraged to switch. The type aliases above should be considered deprecated and will be removed in a future version of VecCore.</p>
<p>Each VecCore backend uses the scalar types to provide equivalent SIMD vector types. For example, the <a href="https://github.com/VcDevel/Vc">Vc</a> backend defines the following types:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacevecCore.html">vecCore</a> {</div>
<div class="line"><span class="keyword">namespace </span>backend {</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_typedef" href="namespacevecCore_1_1backend.html#a32864a5503b92202e1433926448dbb40">VcVector</a> {</div>
<div class="line">    <span class="keyword">using </span>Float_v  = Vc::Vector&lt;float&gt;;</div>
<div class="line">    <span class="keyword">using </span>Double_v = Vc::Vector&lt;double&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Int_v    = Vc::Vector&lt;int&gt;;</div>
<div class="line">    <span class="keyword">using </span>Int32_v  = Vc::Vector&lt;int32_t&gt;;</div>
<div class="line">    <span class="keyword">using </span>Int64_v  = Vc::Vector&lt;int64_t&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>UInt_v   = Vc::Vector&lt;unsigned&gt;;</div>
<div class="line">    <span class="keyword">using </span>UInt32_v = Vc::Vector&lt;uint32_t&gt;;</div>
<div class="line">    <span class="keyword">using </span>UInt64_v = Vc::Vector&lt;uint64_t&gt;;</div>
<div class="line">  };</div>
<div class="line">} <span class="comment">// namespace backend</span></div>
<div class="line">} <span class="comment">// namespace vecCore</span></div>
<div class="ttc" id="anamespacevecCore_1_1backend_html_a32864a5503b92202e1433926448dbb40"><div class="ttname"><a href="namespacevecCore_1_1backend.html#a32864a5503b92202e1433926448dbb40">vecCore::backend::VcVector</a></div><div class="ttdeci">VcVectorT&lt;&gt; VcVector</div><div class="ttdef"><b>Definition:</b> <a href="VcVector_8h_source.html#l00041">VcVector.h:41</a></div></div>
</div><!-- fragment --><p>Note that the absence of a boolean type above is intentional. Since most SIMD hardware units have a fixed width in bits (i.e. 128 bits for SSE, 256 bits for AVX, etc), the number of elements in a vector boolean type (i.e. a SIMD mask) is different for each scalar type. For example, the native SIMD vector type for <code>Double_v</code> when AVX2 is enabled usually contains 4 elements, while <code>Float_v</code> contains 8 elements. Moreover, there can be substantial differences in hardware as well. <a href="http://www.intel.com/xeonphi">Intel® Xeon Phi™</a> processors and coprocessors introduced hardware mask registers instead of using regular SIMD registers for masks, as is done in Core i7 processors (Skylake and earlier). Later, with the addition of AVX512, hardware mask registers have also become available on Xeon and newer Core processors. For more information about SIMD programming on Intel® hardware, please consult the <a href="https://software.intel.com/en-us/articles/intel-sdm">Intel® 64 and IA-32 Architectures Software Developer Manuals</a>.</p>
<p>In VecCore, mask types are defined in terms of their associated vector types via type traits. For example, <code>Mask&lt;Float_v&gt;</code> is the mask type for <code>Float_v</code>, and <code>Mask&lt;Double_v&gt;</code> the mask type for <code>Double_v</code>. Similarly, the type traits define the alias <code>Index&lt;T&gt;</code> which denotes a suitable vector index type for <code>T</code>, and <code>Scalar&lt;T&gt;</code> which maps to the underlying scalar type of <code>T</code>. These dependent types are needed to define the interfaces for gather/scatter in terms of pointers to scalars and vector indices, for example, but are also useful in various other situations.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
SIMD Operations</h2>
<p>For each backend type <code>T</code> representing a SIMD vector type, <code>M</code> its associated mask type, VecCore defines the following functions:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacevecCore.html">vecCore</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> <a class="code hl_function" href="namespacevecCore.html#a547115fed3ce48b2c4ba2fd85b41f6ba">VectorSize</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Scalar&lt;T&gt; <a class="code hl_function" href="namespacevecCore.html#a0bc95998843376452d74d5c8f5337845">Get</a>(<span class="keyword">const</span> T &amp;v, <span class="keywordtype">size_t</span> i);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code hl_function" href="namespacevecCore.html#a211f237ccf30b72af40548291b739272">Set</a>(T &amp;v, <span class="keywordtype">size_t</span> i, Scalar&lt;T&gt; <span class="keyword">const</span> val);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code hl_function" href="namespacevecCore.html#a677e6e32a43336d0f1eb6cf02a8cc5e4">Load</a>(T &amp;v, Scalar&lt;T&gt; <span class="keyword">const</span> *ptr);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code hl_function" href="namespacevecCore.html#af31238a7082520d47d7d867ac03872dd">Store</a>(T <span class="keyword">const</span> &amp;v, Scalar&lt;T&gt; *ptr);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S = Scalar&lt;T&gt;&gt;</div>
<div class="line">  T <a class="code hl_function" href="namespacevecCore.html#aa62e89fe18cec46b0014df8e2766bf4e">Gather</a>(S <span class="keyword">const</span> *ptr, Index&lt;T&gt; <span class="keyword">const</span> &amp;idx);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S = Scalar&lt;T&gt;&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="namespacevecCore.html#a46714c80f9cededdaa04528832578fb8">Scatter</a>(T <span class="keyword">const</span> &amp;v, S *ptr, Index&lt;T&gt; <span class="keyword">const</span> &amp;idx);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt; <span class="keywordtype">bool</span> <a class="code hl_function" href="namespacevecCore.html#a4a739052a81f3a56cdcf64b88480e0c2">MaskFull</a>(M <span class="keyword">const</span> &amp;mask);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M&gt; <span class="keywordtype">bool</span> <a class="code hl_function" href="namespacevecCore.html#a045d76341de9a761a3693f0f7a87ab72">MaskEmpty</a>(M <span class="keyword">const</span> &amp;mask);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code hl_function" href="namespacevecCore.html#a09b76039bbfb2e266c7309e5352b6a15">MaskedAssign</a>(T &amp;dst, <span class="keyword">const</span> Mask&lt;T&gt; &amp;mask, <span class="keyword">const</span> T &amp;src);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T <a class="code hl_function" href="namespacevecCore.html#a1972c89078b634842dc5ffea5c7663de">Blend</a>(<span class="keyword">const</span> Mask&lt;T&gt; &amp;mask, <span class="keyword">const</span> T &amp;src1, <span class="keyword">const</span> T &amp;src2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="namespacevecCore.html#a6cabb8348fb6a9607473396379dac89b">EarlyReturnAllowed</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> <a class="code hl_function" href="namespacevecCore.html#ac0a183b43e5f42a56d454223ece9dc81">EarlyReturnMaxLength</a>(T &amp;v, <span class="keywordtype">size_t</span> n);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Scalar&lt;T&gt; <a class="code hl_function" href="namespacevecCore.html#af5ae6bac35d59b00c29fd4380c615e86">ReduceAdd</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Scalar&lt;T&gt; <a class="code hl_function" href="namespacevecCore.html#ae701e4480574bb9dd38ac3df90884257">ReduceMin</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Scalar&lt;T&gt; <a class="code hl_function" href="namespacevecCore.html#a418a4e9c96935fc85e4e6712489e18ac">ReduceMax</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacevecCore_html_a045d76341de9a761a3693f0f7a87ab72"><div class="ttname"><a href="namespacevecCore.html#a045d76341de9a761a3693f0f7a87ab72">vecCore::MaskEmpty</a></div><div class="ttdeci">VECCORE_ATT_HOST_DEVICE bool MaskEmpty(const M &amp;mask)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00222">Implementation.h:222</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a09b76039bbfb2e266c7309e5352b6a15"><div class="ttname"><a href="namespacevecCore.html#a09b76039bbfb2e266c7309e5352b6a15">vecCore::MaskedAssign</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE void MaskedAssign(T &amp;dst, const Mask&lt; T &gt; &amp;mask, const T &amp;src)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00284">Implementation.h:284</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a0bc95998843376452d74d5c8f5337845"><div class="ttname"><a href="namespacevecCore.html#a0bc95998843376452d74d5c8f5337845">vecCore::Get</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE Scalar&lt; T &gt; Get(const T &amp;v, size_t i)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00106">Implementation.h:106</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a1972c89078b634842dc5ffea5c7663de"><div class="ttname"><a href="namespacevecCore.html#a1972c89078b634842dc5ffea5c7663de">vecCore::Blend</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE T Blend(const Mask&lt; T &gt; &amp;mask, const T &amp;src1, const T &amp;src2)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00292">Implementation.h:292</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a211f237ccf30b72af40548291b739272"><div class="ttname"><a href="namespacevecCore.html#a211f237ccf30b72af40548291b739272">vecCore::Set</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE void Set(T &amp;v, size_t i, Scalar&lt; T &gt; const val)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00114">Implementation.h:114</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a418a4e9c96935fc85e4e6712489e18ac"><div class="ttname"><a href="namespacevecCore.html#a418a4e9c96935fc85e4e6712489e18ac">vecCore::ReduceMax</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE Scalar&lt; T &gt; ReduceMax(const T &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00345">Implementation.h:345</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a46714c80f9cededdaa04528832578fb8"><div class="ttname"><a href="namespacevecCore.html#a46714c80f9cededdaa04528832578fb8">vecCore::Scatter</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE void Scatter(T const &amp;v, S *ptr, Index&lt; T &gt; const &amp;idx)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00204">Implementation.h:204</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a4a739052a81f3a56cdcf64b88480e0c2"><div class="ttname"><a href="namespacevecCore.html#a4a739052a81f3a56cdcf64b88480e0c2">vecCore::MaskFull</a></div><div class="ttdeci">VECCORE_ATT_HOST_DEVICE bool MaskFull(const M &amp;mask)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00213">Implementation.h:213</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a547115fed3ce48b2c4ba2fd85b41f6ba"><div class="ttname"><a href="namespacevecCore.html#a547115fed3ce48b2c4ba2fd85b41f6ba">vecCore::VectorSize</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE constexpr size_t VectorSize()</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00015">Implementation.h:15</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a677e6e32a43336d0f1eb6cf02a8cc5e4"><div class="ttname"><a href="namespacevecCore.html#a677e6e32a43336d0f1eb6cf02a8cc5e4">vecCore::Load</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE void Load(T &amp;v, Scalar&lt; T &gt; const *ptr)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00145">Implementation.h:145</a></div></div>
<div class="ttc" id="anamespacevecCore_html_a6cabb8348fb6a9607473396379dac89b"><div class="ttname"><a href="namespacevecCore.html#a6cabb8348fb6a9607473396379dac89b">vecCore::EarlyReturnAllowed</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE constexpr bool EarlyReturnAllowed()</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00301">Implementation.h:301</a></div></div>
<div class="ttc" id="anamespacevecCore_html_aa62e89fe18cec46b0014df8e2766bf4e"><div class="ttname"><a href="namespacevecCore.html#aa62e89fe18cec46b0014df8e2766bf4e">vecCore::Gather</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE T Gather(S const *ptr, Index&lt; T &gt; const &amp;idx)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00194">Implementation.h:194</a></div></div>
<div class="ttc" id="anamespacevecCore_html_ac0a183b43e5f42a56d454223ece9dc81"><div class="ttname"><a href="namespacevecCore.html#ac0a183b43e5f42a56d454223ece9dc81">vecCore::EarlyReturnMaxLength</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE constexpr bool EarlyReturnMaxLength(T &amp;, size_t n)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00312">Implementation.h:312</a></div></div>
<div class="ttc" id="anamespacevecCore_html_ae701e4480574bb9dd38ac3df90884257"><div class="ttname"><a href="namespacevecCore.html#ae701e4480574bb9dd38ac3df90884257">vecCore::ReduceMin</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE Scalar&lt; T &gt; ReduceMin(const T &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00333">Implementation.h:333</a></div></div>
<div class="ttc" id="anamespacevecCore_html_af31238a7082520d47d7d867ac03872dd"><div class="ttname"><a href="namespacevecCore.html#af31238a7082520d47d7d867ac03872dd">vecCore::Store</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE void Store(T const &amp;v, Scalar&lt; T &gt; *ptr)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00163">Implementation.h:163</a></div></div>
<div class="ttc" id="anamespacevecCore_html_af5ae6bac35d59b00c29fd4380c615e86"><div class="ttname"><a href="namespacevecCore.html#af5ae6bac35d59b00c29fd4380c615e86">vecCore::ReduceAdd</a></div><div class="ttdeci">VECCORE_FORCE_INLINE VECCORE_ATT_HOST_DEVICE Scalar&lt; T &gt; ReduceAdd(const T &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="Implementation_8h_source.html#l00322">Implementation.h:322</a></div></div>
</div><!-- fragment --><div class="image">
<object type="image/svg+xml" data="api.svg" style="pointer-events: none;"></object>
<div class="caption">
VecCore API</div></div>
    <p>These functions can be used to write SIMD-enabled algorithms that can be instantiated with different backends depending on the configuration during compilation. For example, below is an example of such algorithm for computing the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot Set</a>. First, the scalar version:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> mandelbrot(T xmin, T xmax, <span class="keywordtype">size_t</span> nx,</div>
<div class="line">                T ymin, T ymax, <span class="keywordtype">size_t</span> ny,</div>
<div class="line">                <span class="keywordtype">size_t</span> max_iter, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *image)</div>
<div class="line">{</div>
<div class="line">    T dx = (xmax - xmin) / T(nx);</div>
<div class="line">    T dy = (ymax - ymin) / T(ny);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; ++j) {</div>
<div class="line">            <span class="keywordtype">size_t</span> k = 0;</div>
<div class="line">            T x = xmin + T(i) * dx, cr = x, zr = x;</div>
<div class="line">            T y = ymin + T(j) * dy, ci = y, zi = y;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">do</span> {</div>
<div class="line">                x  = zr*zr - zi*zi + cr;</div>
<div class="line">                y  = T(2.0) * zr*zi + ci;</div>
<div class="line">                zr = x;</div>
<div class="line">                zi = y;</div>
<div class="line">            } <span class="keywordflow">while</span> (++k &lt; max_iter &amp;&amp; (zr*zr + zi*zi &lt; T(4.0)));</div>
<div class="line"> </div>
<div class="line">            image[ny*i + j] = k;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then its VecCore equivalent implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> mandelbrot_v(Scalar&lt;T&gt; xmin, Scalar&lt;T&gt; xmax, <span class="keywordtype">size_t</span> nx,</div>
<div class="line">                  Scalar&lt;T&gt; ymin, Scalar&lt;T&gt; ymax, <span class="keywordtype">size_t</span> ny,</div>
<div class="line">                  Scalar&lt;Index&lt;T&gt;&gt; max_iter, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *image)</div>
<div class="line">{</div>
<div class="line">    T iota;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; VectorSize&lt;T&gt;(); ++i)</div>
<div class="line">        Set&lt;T&gt;(iota, i, i);</div>
<div class="line"> </div>
<div class="line">    T dx = T(xmax - xmin) / T((Scalar&lt;T&gt;)nx);</div>
<div class="line">    T dy = T(ymax - ymin) / T((Scalar&lt;T&gt;)ny), dyv = iota * dy;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nx; ++i) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; ny; j += VectorSize&lt;T&gt;()) {</div>
<div class="line">            Scalar&lt;Index&lt;T&gt;&gt; k(0);</div>
<div class="line">            T x = xmin + T((Scalar&lt;T&gt;)i) * dx,       cr = x, zr = x;</div>
<div class="line">            T y = ymin + T((Scalar&lt;T&gt;)j) * dy + dyv, ci = y, zi = y;</div>
<div class="line"> </div>
<div class="line">            Index&lt;T&gt; kv(0);</div>
<div class="line">            Mask&lt;T&gt; m(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">do</span> {</div>
<div class="line">                x = zr*zr - zi*zi + cr;</div>
<div class="line">                y = T((Scalar&lt;T&gt;)2.0) * zr*zi + ci;</div>
<div class="line">                MaskedAssign&lt;T&gt;(zr, m, x);</div>
<div class="line">                MaskedAssign&lt;T&gt;(zi, m, y);</div>
<div class="line">                MaskedAssign&lt;Index&lt;T&gt;&gt;(kv, m, ++k);</div>
<div class="line">                m = zr*zr + zi*zi &lt; T((Scalar&lt;T&gt;)4.0);</div>
<div class="line">            } <span class="keywordflow">while</span> (k &lt; max_iter &amp;&amp; !MaskEmpty(m));</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; VectorSize&lt;T&gt;(); ++k)</div>
<div class="line">                image[ny*i + j + k] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) Get(kv, k);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>While the two implementations are similar to each other, some important differences should be noted. The <code>do/while</code> loop, for example, needs to process several pixels of the image at once, hence a mask is required to check for loop termination rather than a simple counter. The mask is also used to restrict the elements to which an update should be applied at each iteration. This is a common theme in SIMD programming. For more examples of the application of the VecCore interfaces, we encourage the reader to read the Mandelbrot and other examples in the <a href="https://github.com/root-project/veccore/tree/master/bench">VecCore repository on GitHub</a>.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Arithmetics, Comparisons, and Logical Operations</h2>
<p>VecCore backend types support usual arithmetic operations, such as addition, multiplication, etc, except for the modulus operation, which is not supported by most hardware. Comparisons and logical operations are also supported, with the caveat that the result of a vector comparison or logical operation is not a boolean, but an appropriate mask type. Therefore, such operations should not be part of an <code>if</code> or similar construct, as this will almost certainly lead to a bug. The correct way to use such expressions in branching code is to test wether the mask has none, any, or all of its elements set, and take appropriate action:</p>
<div class="fragment"><div class="line"><span class="comment">// example: set negative elements of x to 0.0</span></div>
<div class="line"> </div>
<div class="line">Double_v Clamp(Double_v x) {</div>
<div class="line">  Mask&lt;Double_v&gt; m = x &lt; 0.0;</div>
<div class="line">  <span class="keywordflow">if</span> (!MaskEmpty(m)) {</div>
<div class="line">    MaskedAssign(x, m, 0.0);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the case above, the condition may be ommitted, but in cases where the operations inside the condition are expensive, it is worth to check if any elements really need to be calculated.</p>
<p>An important aspect of VecCore to keep in mind is that the backends provide direct aliases to the real types offered by the different libraries like Vc, UME::SIMD, and now std::experimental::simd. This is the main reason why we cannot use <code>v[i]</code> to access elements of a SIMD vector, as that would not work with plain scalars (i.e. <code>float</code> or <code>int</code>). We need to provide this interface via a function instead, in the form of <code>vecCore::Get(v, i)</code>. Nevertheless, if the user knows they will never need to use the plain scalar backend (or if using the provided wrappers for scalars in the <code>ScalarWrapper</code> backend, despite a potential performance penalty), then it is fine to use <code>v[i]</code> to access elements of SIMD vectors, as that is actually provided by all SIMD backends. However, other restrictions also apply. For example, in order to construct a SIMD vector of <code>float</code>s using <code>std::experimental::simd</code>, a plain constant like <code>0.0</code> is not acceptable, so it may be necessary to cast integer and double precision constants to <code>float</code>. The Vc and UME::SIMD backends do not have this restriction. Comparing masks is also not recommended, as the result may be either another mask or a boolean that is true if the masks are identical depending on the backend.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Mathematical Functions</h2>
<p>VecCore provides implementations for mathematical functions with SIMD types for each backend in the namespace <code><a class="el" href="namespacevecCore_1_1math.html">vecCore::math</a></code>. In recent versions, this namespace has been converted into an inline namespace to avoid long names for the functions. Function names were capitalized to avoid clashes with standard functions, but they map to standard functions when the backend library does not offer a more specialized implementation. Therefore, calling <code>vecCore::Sin(x)</code>, for example, is possible with any of the backend types. Please access the online <a href="https://root-project.github.io/veccore/namespacevecCore_1_1math.html">Doxygen documentation</a> for a full list of all the mathematical functions defined in the backends. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
