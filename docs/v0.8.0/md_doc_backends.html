<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VecCore: VecCore Backends</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VecCore
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
   <div id="projectbrief">C++ Library for Portable SIMD Vectorization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc_backends.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">VecCore Backends </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes each backend available in VecCore. Each backend has advantages and disadvantages, depending on the circumstances. The advantage of using VecCore rather than the libraries themselves is that with VecCore the backend can usually be swapped without requiring any changes to the user's own algorithms, to take advantage of the implementation with the best performance, while also having a fallback on architectures not supported by the SIMD libraries themselves. VecCore interfaces are also annotated for CUDA, so in combination with the scalar backend this allows one to write code that is portable between CPU and GPU where that makes sense. With the addition of new backends, such as the backend based on C++20 <code>std::experimental::simd</code>, VecCore also allows users to take advantage of new features automatically.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Scalar Backend</h2>
<p>This backend maps VecCore types to plain scalars. This choice was made such that algorithms could be specialized for the scalar case if necessary without having a performance penalty. It can also be used as a fallback on architectures not supported by other backends, like on PowerPC architecture, and when writing code that needs to run on GPUs, as VecCore API functions are annotated for CUDA.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
ScalarWrapper Backend</h2>
<p>This backend is similar to the scalar backend, but maps VecCore types to wrappers around plain scalars, so that a better syntax can be used for accessing elements (e.g. <code>v[i]</code> instead of <code>vecCore::Get(v, i)</code>). Although it may incur a performance penalty relative to the plain scalar backend in some cases, it often performs almost the same, while allowing more readable code to be written in a portable way.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Vc Backends</h2>
<p>The <a href="https://github.com/VcDevel/Vc">Vc</a> library is used to offer several different backends. The <code>VcScalar</code> backend functions in a similar way to the <code>ScalarWrapper</code> backend that is native to VecCore. It simply maps to wrappers around scalars and allow writing code with better syntax. The <code>VcVector</code> backend is the main SIMD backend used by VecCore users. It offers excellent performance with SSE2, SSE4, and AVX2. However, it should not be used with AVX-only since Vc does not add fallback implementations for the integer vector types when they are not available in hardware. This backend does not support newer instructions sets like AVX512. The Vc library has been in maintenance mode since a few years, with new effort being focused on the C++20 standard for vector data types (<code>std::experimental::simd</code>). VecCore also offers wrappers to vectors of fixed length using Vc, via the <code>VcSimdArray&lt;N&gt;</code> backend. This backend is templated on the SIMD length and can be used where varying the vector length depending on the architecture is not desirable.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
UME::SIMD Backends</h2>
<p>The <a href="https://github.com/edanor/umesimd">UME::SIMD</a> backend was added in order to have a way to support AVX512, as that was the focus of the library when it was created. However, since the UME::SIMD library has not seen any development in a long time, this backend should be considered deprecated and shall be removed in a future version of VecCore. Although performance with AVX512 is very good with the UME::SIMD backends, UME::SIMD only compiles with the Intel C/C++ compiler in AVX512 mode and therefore cannot be used with GCC or Clang. Although this problem does not affect SSE4 or AVX2, this backend is not recommended for these microarchitectures, since the UME::SIMD implementation often falls back to scalar code for SSE4/AVX2 and does not perform as well as the Vc backends in these cases.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
C++20 SIMD Backend (using &lt;tt&gt;std::experimental::simd&lt;/tt&gt;)</h2>
<p>The latest backend to be added to VecCore, the C++20 SIMD backend uses the implementation of <code>std::experimental::simd</code> provided by GCC 11. This backend offers the best of both Vc and UME::SIMD, as it performs well in most cases, from SSE2 up to AVX512. However, it does require a recent version of GCC and compiling your code with C++20. This backend also offers scalar wrappers in the form of the <code>SIMDScalar</code> backend in VecCore, which uses the scalar ABI provided by <code>std::experimental::simd</code>. The recommended way to use this backend is via the <code>SIMDNative</code> VecCore backend, which will map all vector types to their native SIMD types depending on what is enabled at compile time. While VecCore does offer the templated <code>SIMDArray&lt;N&gt;</code> backend that maps to fixed-size SIMD types from the standard implementation, it is not recommended to be used for the moment, as performance is significantly impacted relative to the native backend. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
